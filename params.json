{"name":"Typed JSON","tagline":"Format for defining structured JSON data","body":"# Typed JSON\r\n\r\nTyped JSON is a format for defining structured [JSON][] data, that\r\ncan be used by language type systems or contract / guard librarires\r\nto do some type safety guarantees.\r\n\r\n## Format\r\n\r\nEvery type is associtade with a unique URI. It is recommended to have a type\r\ndefinition under that URI, but it is not a requirement, it is up to implementor\r\nto associate actual definitions with a URI, in other words type URIs are just\r\na unique identifiers for types.\r\n\r\nFormat defines some base primitive types that are also associated with specific\r\nURIs. This specification recognizes following primitive types:\r\n\r\n### Null\r\n\r\nPrimitive type representing an absense of value. In the type vocabulary they\r\ncan be referenced either by URI or aliased as a local type and referced by\r\nalias name:\r\n\r\n\r\n```json\r\n{\r\n  \"null\": \"http://typed-json.org/#Null\"\r\n}\r\n```\r\n\r\n*Note: Above definition defines `\"null\"` just as an alias to primitive\r\nhttp://typed-json.org/#null type, so that rest of the type vocabulary\r\nwould be able to refer to it by that identifier.*\r\n\r\n\r\nSince `null` is valid JSON primitive it can be used instead of URI\r\nhttp://typed-json.org/#null. For example type `empty` can be defined\r\nas an alias to http://typed-json.org/#null as follows:\r\n\r\n```json\r\n{\r\n  \"empty\": null\r\n}\r\n```\r\n\r\n\r\n### Boolean\r\n\r\nBoolean type can be aliased as `bool` as follows:\r\n\r\n```json\r\n{\r\n  \"bool\": \"http://typed-json.org/#boolean\"\r\n}\r\n```\r\n\r\n\r\n### Int\r\n\r\nInts type can be aliased as `int` as follows:\r\n\r\n```json\r\n{\r\n  \"int\": \"http://typed-json.org/#int\"\r\n}\r\n```\r\n\r\n*Note: int is JS int*\r\n\r\n### Float\r\n\r\nFloat type can be aliased as `float` as follows:\r\n\r\n```json\r\n{\r\n  \"float\": \"http://typed-json.org/#float\"\r\n}\r\n```\r\n\r\n### String\r\n\r\nString type can be aliased as `float` as follows:\r\n\r\n```json\r\n{\r\n  \"string\": \"http://typed-json.org/#string\"\r\n}\r\n```\r\n\r\n## Composite types\r\n\r\nTyped JSON is used mainly for defining composite type structures. There are\r\nfew type structures that can be expressed:\r\n\r\n### Records\r\n\r\nRecord types represent JSON objects with a specific structure. They are\r\ndefined in terms of field type signatures:\r\n\r\n\r\n```json\r\n{\r\n  \"point\": {\r\n    \"x\": \"http://typed-json.org/#int\",\r\n    \"y\": \"http://typed-json.org/#int\"\r\n  }\r\n}\r\n```\r\n\r\nAbove JSON defines `point` type that **Must** have `x` and `y` fields\r\nof `int` type. This example uses full URIs to for field type definitions,\r\nbut that's redundant and could be expressed in more eloquent manner:\r\n\r\n\r\n```json\r\n{\r\n  \"int\": \"http://typed-json.org/#int\",\r\n  \"point\": { \"x\": \"int\", \"y\": \"int\" }\r\n}\r\n```\r\n\r\nComposite data type definitions can refer to other composite types:\r\n\r\n```json\r\n{\r\n  \"int\": \"http://typed-json.org/#int\",\r\n  \"point\": { \"x\": \"int\", \"y\": \"int\" },\r\n  \"line\": {\r\n    \"start\": \"point\",\r\n    \"end\": \"point\"\r\n  }\r\n}\r\n```\r\n\r\n### Collections\r\n\r\nCollections like arrays (different languages could use different collection\r\ntypes, lists for example) must contain items of certain type(s) and are defined\r\nas follows:\r\n\r\n```json\r\n{\r\n  \"int\": \"http://typed-json.org/#int\",\r\n  \"point\": { \"x\": \"int\", \"y\": \"int\" },\r\n  \"shape\": [\"point\"]\r\n}\r\n```\r\n\r\n*Note: Above example above defines `shape` type that is\r\ncollection of `point` type items of arbitrary number*\r\n\r\nFollowing JSON data would match `shape` type:\r\n\r\n```js\r\n[{\"x\":0, \"y\":0}]\r\n[{\"x\":0, \"y\":0}, {\"x\": 0, \"y\": 10}]\r\n[{\"x\":0, \"y\":0}, {\"x\": 0, \"y\": 10}, {\"x\": 10: \"y\": 10}]\r\n```\r\n\r\nIt is also possible to define fixed size collections:\r\n\r\n\r\n```json\r\n{\r\n  \"int\": \"http://typed-json.org/#int\",\r\n  \"point\": [int, 2]\r\n  \"line\": [\"point\", 2]\r\n}\r\n```\r\n\r\nFollowing JSON data would match `line` type definition:\r\n\r\n```js\r\n[[0,0], [0,10]]\r\n[[0,0], [10,10]]\r\n```\r\n\r\n### Tuples\r\n\r\nTuples are fixed size JS arrays, in contrast to regular fixed\r\nsize arrays they define element types by index and there for\r\nare preferable for defining mixed type arrays:\r\n\r\n```json\r\n{\r\n  \"int\": \"http://typed-json.org/#int\",\r\n  \"string\": \"http://typed-json.org/#string\",\r\n  \"color\": \"string\",\r\n  \"point\": { \"x\": \"int\", \"y\": \"int\" },\r\n  \"pixel\": {\r\n    \"0\": \"point\",\r\n    \"1\": \"color\"\r\n  }\r\n}\r\n```\r\n\r\nAbove defined `pixel` type defines structure for values like:\r\n\r\n```js\r\n[{x:0, y:0}, \"red\"]\r\n[{x:0, y:12}, \"green\"]\r\n````\r\n\r\n*Note: That \"color\" is just an alias for a string with a different\r\nsemantic meaning. It's useful to give semantic meaning to an entities\r\nused in type definitions, that allows changing types of those entities\r\nindependently from computed types*\r\n\r\n## Metadata\r\n\r\nNew primitives can be defined by aliasing existing primitive types\r\nand adding some additional metadata. For example type `digit` can\r\nbe defined as:\r\n\r\n```json\r\n{\r\n  \"digit\": \"http://typed-json.org/#int\",\r\n  \"digit:meta\": {\r\n    \"min\": 0,\r\n    \"max\": 9\r\n  }\r\n}\r\n```\r\n\r\nNote that above definition uses \"digit:meta\" key to define metadata\r\nfor the `digit` type. Metadata keys must be mapped to an objects who's\r\nfields are not specified by this format. Different environments may\r\nchoose to support metadata fields, for example `digit` type metadata\r\nspecifies range of ints, but if runtime does not supports ranges it\r\nwill still treat `digit` as `int` type.\r\n\r\n## Constants\r\n\r\nSpecification recognizes constants of `string`, `integer`, `float`\r\nand `boolean` types:\r\n\r\n```json\r\n{\r\n  \"readyStatus\": 1,\r\n  \"readyState\": \"'complete'\",\r\n  \"yes\": \"true\",\r\n}\r\n```\r\n\r\nAbove data structure defines type `readyStatus` constant of `int`\r\ntype that will only match `1`. Type `yes` is a boolean that is\r\n`true`. Type `readyState` is a constant primitive that matches\r\n`\"complete\"` string in JSON although in some languages that could\r\ntranslate to more appropriate contant values like [keywords][]\r\nin clojure.\r\n\r\n\r\n## Union types\r\n\r\nComposite types can also be defined in form of [union types][] to\r\nallow structures that can contain either of listed types:\r\n\r\n```json\r\n{\r\n  \"string\": \"http://typed-json.org/#string\",\r\n  \"pending\": {\"pending\":\"true\"},\r\n  \"complete\": {\"data\": \"string\"}\r\n  \"status\": \"pending|complete\"\r\n}\r\n```\r\n\r\n\r\nUnions can be defined over constant types as well:\r\n\r\n\r\n```json\r\n{\r\n  \"yes\": \"'yes'\",\r\n  \"no\": \"'no'\",\r\n  \"show\": \"yes|no\"\r\n}\r\n```\r\n\r\nThere is also syntax sugar to express above in more\r\nconsise way:\r\n\r\n```json\r\n{\r\n  \"show\": \"'yes'|'no'\"\r\n}\r\n```\r\n\r\n*Note: Union types support syntax sugar over string type constants\r\nall others have to be defined as types explicitly*\r\n\r\n```json\r\n{\r\n  \"two\": 2,\r\n  \"three\": 3,\r\n  \"five\": 5,\r\n  \"seven\": 7,\r\n  \"primedigits\": \"two|three|five|seven\"\r\n}\r\n```\r\n\r\n\r\n# Prior art:\r\n\r\n- [Elm records](http://elm-lang.org/learn/Records.elm)\r\n- [MongoDB BSON](http://bsonspec.org/)\r\n- [JSON Schema](http://json-schema.org/)\r\n- [Protocol buffers](https://developers.google.com/protocol-buffers/docs/overview)\r\n\r\n[JSON]:http://json.org/\r\n[structural typing]:http://en.wikipedia.org/wiki/Structural_type_system\r\n[keywords]:http://clojure.org/data_structures#Data%20Structures-Keywords\r\n[Union_types]:https://en.wikipedia.org/wiki/Union_type","google":"UA-42944832-1","note":"Don't delete this file! It's used internally to help with page regeneration."}